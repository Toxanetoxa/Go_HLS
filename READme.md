# Структура проекта
```
go_hls/
├── cmd/
│   ├── go_hls/
│   │   └── main.go
│   └── migrate/
│       └── main.go
├── config/
├── docker/
│   ├── app.Dockerfile
│   └── nginx.Dockerfile
├── internal/
│   ├── auth/
│   │   ├── handler.go
│   │   └── middleware.go
│   ├── db/
│   │   ├── connect.go
│   │   └── migration.go
│   ├── user/
│   │   └── users.go
│   └── video/
│       ├── handler.go
│       └── video.go
├── migrations/
├── pkg/
│   └── logger/
│       └── logger.go
├── .ENV
├── .ENV.EXAMPLE
├── .gitignore
├── docker-compose.yaml
├── Makefile
└── READme.md
```

### !!! Прежде всего создайте .ENV фаил по примеру .ENV.EXAMPLE !!!

##  Сборка и запуск приложения:
В проекте используется Make все команды можно посмотреть 
```shell
  make help 
```
### Рекомендуемая команда при первом запуске:
```shell
   make start
```

### Команда бля билда докер образа:
```shell
  make build
```
### Команда для поднятия контейнеров в дев режиме
```shell
  make up
```

#### Важно добавить в **etc/hosts** строчку
```
127.0.0.1   backend.app.loc
```

## Приложение будет доступно по адресу (если вы следовали инструкции):
### [backend.app.loc](http://backend.app.loc)
- Само приложение будет доступно на порту 8080
- Nginx будет доступен на порту 80 (Точнее он будет проксировать приложение на 80ый порт, можно добавить SSL и настроить на 81)
- Redis будет доступен по порту 6379
- PostgresDB будет работать на порту 5432
#### !!!! Важно чтобы у вас ничего другого не крутилось в фоновом режиме на этих портах)

## Основные компоненты:
1. Само приложение на Go:
   * Go 1.22
   * Gin  HTTP-веб-фреймворк
2. Nginx - в качестве прокси-сервера
3. Docker и Docker-Compose для разработки, доставки и запуска приложения в изолированном контейнере.

# ТЗ:

## Цель
Создать прототип api-first (backend отдельно от фронтенд) мини-сервиса на Go (версии 1.21+) для видеостриминга (условный «мини-YouTube») со следующими возможностями:
- Регистрация и авторизация
- Получение и загрузка видеоконтента.
- Подсчёт просмотров и отображение количества текущих зрителей в реальном времени.

## Задачи
1. Реализовать регистрацию и авторизацию пользователей на базе JWT.
2. Поддержать загрузку хотя бы одного небольшого файла. Хранить метаданные видео (название, путь к файлу, автор и т. п.) в базе данных PostgreSQL.
3. Создать эндпоинт, позволяющий «пролистывать» видео без полной перезагрузки.
4. Отслеживать в реальном времени, сколько пользователей прямо сейчас смотрит видео.  Отображать общее количество просмотров (как минимум увеличивать счётчик при первом просмотре). Напишите как бы вы решили проблему борьбы с накруткой счетчика просмотра в реальном проекте.
5. Минимальный фронтенд (опционально, но приветствуется). Будет плюсом, если для демонстрации будет сделан простой HTML-интерфейс (без сложных стилей).


# Маршруты:
- POST /auth/register — регистрация (email + хешированный пароль).
- POST /auth/login — получение JWT-токена.
- GET /auth/me — получение данных пользователя (с проверкой токена).
- POST /videos/upload — загрузка видео (multipart/form-data).
- GET /videos/{id}/stream 

# Технологии
- Backend: Go 1.21 + Gin
- Database: PostgreSQL (gorm)
- Caching: Redis (активные зрители)
- JWT: github.com/golang-jwt/jwt/v5
- Storage: Локально (storage/) или MinIO (S3)
- WebSocket: github.com/gorilla/websocket

## DONE list
- Реализована базова регистрация и авторизация
- Реализован защищённая ручка для загрузки видео
- Реализована ручка для просмотра видео
- Всё поднимается в Docker контейнерах
- Есть Makefile команда, которая поможет
```sh
    make help
```
- Используется Nginx для удобства
- Есть миграции запускаются тоже с помощью Make
- Есть люггер


## TODO list
- Отладить код
- Создать эндпоинт, позволяющий «пролистывать» видео без полной перезагрузки.
- Сделать простенький фронтенд
- Отрегулировать счётчик
- Написать тесты
- *Подумать по поводу уязвимостей
- *Подумать про масштабируемость
- Добавить кеширование в редисе, чтобы снизить нагрузку на бд (Метаданные видео, пользователей, какие-нибудь счётчики?). *Подумать
- Реализовать swagger для удобства
- Поправить докер файлв чтобы креды для бд брались из env


# FOR FRONTEND

На стороне клиента можно использовать WebSocket для получения данных о количестве активных зрителей:
```javascript
const videoId = 1; // Замените на ID видео
const socket = new WebSocket(`ws://backend.app.loc/videos/${videoId}/active-viewers`);

socket.onmessage = function (event) {
const data = JSON.parse(event.data);
console.log("Active viewers:", data.active_viewers);
// Обновите интерфейс, чтобы отобразить количество активных зрителей
};

socket.onclose = function () {
console.log("WebSocket connection closed");
};
```

### Тестовые запросы (only for me):
curl -X POST http://backend.app.loc/videos/upload \
-F "file=@/Users/antonsotnik/Documents/meine/test.mov" \
-F "title=My Video" \
-F "author_id=1"

curl -v -H "Range: bytes=0-1023" http://backend.app.loc/videos/1/stream --output video_part.mp4

curl -X GET http://backend.app.loc/videos/1/stream